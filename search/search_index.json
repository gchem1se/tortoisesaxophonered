{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Computer Architecture and Operating Systems 2024/2025","text":"<p>Welcome to the documentation for the CAOS 2024/2025 project. This documentation provides comprehensive information about the project structure, setup instructions, and API references.</p>"},{"location":"#project-overview","title":"Project Overview","text":"<p>This project focuses on embedded systems development using ARM architecture, specifically targeting the NXP S32K3X8 platform. It includes examples and utilities for working with various peripherals and features of the microcontroller.</p>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>Installation Guide</li> <li>Examples Overview</li> </ul>"},{"location":"#project-structure","title":"Project Structure","text":"<pre><code>caos-2024/\n\u251c\u2500\u2500 examples/     # Example code and demonstrations\n\u251c\u2500\u2500 lpuart.*      # UART communication implementation\n\u251c\u2500\u2500 startup.c     # System startup code\n\u251c\u2500\u2500 main.c        # Main application entry point\n\u2514\u2500\u2500 linker.ld    # Linker script for memory layout\n</code></pre>"},{"location":"#development-process","title":"Development Process","text":"<p>Our project involved several key development phases:</p> <ol> <li> <p>Architecture Setup</p> </li> <li> <p>Added AVR32 architecture support to QEMU</p> </li> <li> <p>Created the NXP S32K3X8EVB SoC implementation, adapting from existing QEMU implementations</p> </li> <li> <p>LPUART Implementation</p> </li> <li> <p>Implemented Low Power UART functionality</p> </li> <li>Adapted code from existing QEMU implementations</li> <li> <p>Fine-tuned register masks and bits according to CPU documentation</p> </li> <li> <p>Memory Configuration</p> </li> <li> <p>Modified linker script to define correct memory regions:</p> <ul> <li>MACHESO: 128K for vector table</li> <li>PFLASH: 2M for program flash</li> <li>DFLASH: 128K for data flash</li> <li>SRAM0-2: 256K each for system RAM</li> </ul> </li> <li> <p>Updated startup code to properly initialize memory regions</p> </li> <li> <p>Peripheral Integration</p> </li> <li>Implemented GPIO support for LED control</li> <li>Integrated FreeRTOS for task management</li> <li>Created example program demonstrating all components working together</li> </ol>"},{"location":"examples/overview/","title":"Examples Overview","text":""},{"location":"examples/overview/#project-components","title":"Project Components","text":"<p>This project demonstrates the successful integration of several key components in QEMU:</p> <ol> <li> <p>S32K3X8 Board Support: We've extended QEMU to support the NXP S32K3X8 development board, enabling accurate hardware simulation.</p> </li> <li> <p>LPUART (Low Power Universal Asynchronous Receiver/Transmitter): Implementation of serial communication capabilities.</p> </li> <li> <p>GPIO (General Purpose Input/Output): Support for digital input/output operations, specifically for LED control.</p> </li> <li> <p>FreeRTOS Integration: Real-time operating system support for task management and scheduling.</p> </li> </ol>"},{"location":"examples/overview/#main-example-interactive-led-control","title":"Main Example: Interactive LED Control","text":"<p>The main example demonstrates the integration of all these components in a practical application. The example allows users to control an LED through keyboard input, showcasing the interaction between:</p> <ul> <li>LPUART: Handles serial communication for keyboard input</li> <li>GPIO: Controls the LED state (on/off)</li> <li>FreeRTOS: Manages tasks and system resources</li> </ul>"},{"location":"examples/overview/#how-it-works","title":"How It Works","text":"<ol> <li>Serial Communication:</li> <li>The LPUART peripheral is configured to receive keyboard input</li> <li> <p>Users can send commands through the serial interface</p> </li> <li> <p>LED Control:</p> </li> <li>The GPIO peripheral is configured to control the LED</li> <li> <p>The LED state can be toggled based on user input</p> </li> <li> <p>Task Management:</p> </li> <li>FreeRTOS manages different tasks:<ul> <li>Serial communication monitoring</li> <li>LED state control</li> <li>System management</li> </ul> </li> </ol>"},{"location":"examples/overview/#code-structure","title":"Code Structure","text":"<p>The example code is organized into several key components:</p> <pre><code>examples/\n\u251c\u2500\u2500 startup.c     # System initialization\n\u251c\u2500\u2500 main.c        # Main application logic\n\u2514\u2500\u2500 lpuart.*      # UART communication implementation\n</code></pre>"},{"location":"examples/overview/#testing-the-example","title":"Testing the Example","text":"<ol> <li>Build and run the project as described in the Installation Guide</li> <li>Once running, you can interact with the LED through keyboard input</li> <li>The LED state will change according to your commands</li> </ol>"},{"location":"examples/overview/#future-enhancements","title":"Future Enhancements","text":"<p>The current implementation serves as a foundation for more complex applications. Possible enhancements could include:</p> <ul> <li>Additional peripheral support</li> <li>More complex GPIO configurations</li> <li>Advanced FreeRTOS task implementations</li> <li>Extended communication protocols</li> </ul>"},{"location":"getting-started/installation/","title":"Installation Guide","text":"<p>This guide will walk you through the process of setting up the CAOS project environment.</p>"},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<p>Before starting, ensure you have the following tools installed on your system:</p> <ul> <li>Git</li> <li>GCC for ARM architecture</li> <li>GDB Multiarch</li> <li>Make</li> </ul>"},{"location":"getting-started/installation/#clone-the-repository","title":"Clone the Repository","text":"<p>First, clone the repository with all its submodules (including QEMU):</p> <pre><code>git clone --recurse-submodules https://github.com/gchem1se/caos-2024.git\ncd caos-2024\n</code></pre>"},{"location":"getting-started/installation/#qemu-setup","title":"QEMU Setup","text":"<ol> <li>Navigate to the QEMU directory:</li> </ol> <pre><code>cd qemu\n</code></pre> <ol> <li>Configure QEMU for ARM architecture:</li> </ol> <pre><code>./configure --target-list=arm-softmmu\n</code></pre> <ol> <li>Build QEMU (this may take a few minutes):</li> </ol> <pre><code>make -j\n</code></pre> <ol> <li>Return to the main project directory:</li> </ol> <pre><code>cd ..\n</code></pre>"},{"location":"getting-started/installation/#building-and-running-the-project","title":"Building and Running the Project","text":""},{"location":"getting-started/installation/#normal-execution","title":"Normal Execution","text":"<ol> <li>Build the project:</li> </ol> <pre><code>make\n</code></pre> <ol> <li>Start QEMU:</li> </ol> <pre><code>make qemu_start\n</code></pre>"},{"location":"getting-started/installation/#debugging","title":"Debugging","text":"<ol> <li>Build the project:</li> </ol> <pre><code>make\n</code></pre> <ol> <li>Start QEMU in debug mode:</li> </ol> <pre><code>make qemu_debug\n</code></pre> <ol> <li>In a separate terminal, start GDB:</li> </ol> <pre><code>gdb-multiarch main.elf\n</code></pre> <ol> <li>Connect GDB to QEMU:</li> </ol> <pre><code>(gdb) target remote localhost:1234\n</code></pre> <p>Now you're ready to debug your application. You can use standard GDB commands like:</p> <ul> <li><code>break</code> to set breakpoints</li> <li><code>continue</code> to resume execution</li> <li><code>step</code> to step through code</li> <li><code>print</code> to examine variables</li> </ul>"},{"location":"getting-started/installation/#troubleshooting","title":"Troubleshooting","text":"<p>If you encounter any issues:</p> <ol> <li>Ensure all prerequisites are correctly installed</li> <li>Make sure all submodules were properly cloned</li> <li>Check that QEMU was built successfully</li> <li>Verify that the correct ARM toolchain is in your PATH</li> </ol>"},{"location":"tutorial/before_you_begin/","title":"Before you begin: QEMU fundamentals","text":"<p>Before proceeding to describe how to add support for a custom (or not officially integrated) ARM-based embedded board in the QEMU emulator, we would like to introduce the reader to some of the basics of QEMU's logic.</p>"},{"location":"tutorial/before_you_begin/#qemus-object-model-qom","title":"QEMU's object model (QOM)","text":"<p>QEMU is such a large and complex project that the developers had to write a substantial amount of code just to implement object-oriented-like features in plain C. QEMU's object model even enables extensions and inheritance, but it's not clearly matchable with Java-like OOP paradigm.</p> <p>\u26a0\ufe0f Class vs. entity</p> <p>From this moment on, we will refer to the concept of \"class\" as it is intended in Java-like programming languages using the term \"entity\", so that we don't have semantic overlapping with the term \"Class\" as it is used in the QOM with a different meaning.</p> <ul> <li>States: variables having type ending in -State are structures used to keep track of the current configuration of the device at runtime. For example, if the Device is a peripheral, its State will contain mostly registers that mimick the HW, maybe interrupt lines, as well as some flags or variables for configuring aspects of the emulation of the peripheral.</li> <li>The State is sometimes referred to as instance.</li> <li>Type: inside of a Type the developer must insert high-level properties of the entity they want to code: its name, its parent class (for inheritance), its instance size (which corresponds to the <code>sizeof</code> its State), the initialization function for its State and the initialization function for its Class. </li> <li>Once the developer registers the Type using specific macros, they won't explicitly interact with it in the code anymore. Instead, QEMU\u2019s QOM (QEMU Object Model) system uses it internally. What the developer cares about is that registering the Type allows them to specify the parent class for inheritance and ensures that the object will be instantiated by using the function <code>object_new(&lt;type.name&gt;)</code>.</li> <li>In the end, every HW component which is part of the emulated environment in QEMU inherits from the Device Type, explicitly or indirectly.</li> <li>Classes: Every Type has an associated Class. The Class is a structure holding function pointers; basically, the developer must put inside the Class pointers to methods of the entity.</li> </ul>"},{"location":"tutorial/before_you_begin/#example-a-simplfied-uart","title":"Example: a simplfied UART","text":"<p>Let's see the QOM in action when implementing in a simplified example of constructing a simplified UART entity:</p> <ol> <li>Creating the State structure, which holds attributes of the entity     <pre><code>typedef struct UARTState {\n    DeviceState parent_obj;   // Mandatory: Inherits from QEMU's DeviceState\n\n    uint8_t tx_reg;           // Transmit register (TX)\n} UARTState;\n</code></pre></li> <li>Defining methods of the entity     <pre><code>static void uart_write_tx(UARTState *s, uint8_t value) {\n    s-&gt;tx_reg = value;  // Store value in the register\n    qemu_log(\"[UART] Sent: 0x%02x ('%c')\\n\", value, value);\n}\n</code></pre></li> <li>Defining the Class structure, which holds methods of the entity     <pre><code>typedef struct UARTClass {\n    DeviceClass parent_class;\n    void (*write_tx)(UARTState *s, uint8_t value);\n} UARTClass;\n</code></pre></li> <li>Defining the constructor of the entity     <pre><code>static void uart_class_init(ObjectClass *klass, void *data) {\n    DeviceClass *dc = DEVICE_CLASS(klass);\n    UARTClass *uartc = (UARTClass *)klass;\n\n    uartc-&gt;write_tx = uart_write_tx;  // Set the TX write function\n}\n</code></pre></li> <li>Defining and registering the Type     <pre><code>static const TypeInfo uart_type_info = {\n    .name = \"uart\",            // Device type name\n    .parent = TYPE_DEVICE,     // Inherits from Device\n    .instance_size = sizeof(UARTState),\n    .class_init = uart_class_init,\n};\n\nstatic void uart_register_types(void) {\n    type_register_static(&amp;uart_type_info);\n}\n\ntype_init(uart_register_types) // no ; here\n</code></pre></li> <li>Using the device     <pre><code>// `object_new` creates any object, \n// specifying the name as a string parameter.\nObject *obj = object_new(\"uart\"); \n\n// like this we convert the generic type to the real one,\n// getting an instance of the entity\nUARTState *state = UART(obj);     \n\n// if we want to access methods, \n// we must initialize the Class of the entity, \n// where pointers to methods are declared\nUARTClass *class = UART_GET_CLASS(state);\n\n// now we can call the method\nif (class-&gt;write_tx) {\n    class-&gt;write_tx(state, 'A');  // Send ASCII 'A'\n}\n</code></pre></li> </ol>"},{"location":"tutorial/before_you_begin/#folder-structure","title":"Folder structure","text":"<p>QEMU's source code follows a modular organization, with C source files (<code>.c</code>) and header files (<code>.h</code>) located in separate directories based on the specific architecture, board or component they are related to. </p> <p>The emulated HW components' C files for both the ARM architecture itself (eg. <code>armv7m.c</code>, implementing the architecture of the ARM Cortex M7 processor) and the ARM-based boards are under <code>qemu/hw/arm</code>, while header files are under <code>qemu/include/hw</code>. </p> <p>Peripherals for the ARM-based boards, instead, are to be found under <code>qemu/hw/arm/&lt;peripheral&gt;</code> and <code>qemu/include/hw/arm/&lt;peripheral&gt;</code>, along with peripherals for boards based on different architectures. </p> <p>For example, various implementations of already supported UART/USART peripherals are under <code>qemu/hw/char</code> and <code>qemu/include/hw/char</code>, like <code>stm32f2xx_usart.c</code>.</p>"},{"location":"tutorial/building_requirements/","title":"Building requirements","text":""},{"location":"tutorial/building_requirements/#needed-packages","title":"Needed packages","text":"<p>To execute the building process, you need some packages on your system. You may install those by running this script on a Linux machine (Debian based): <pre><code>#!/bin/bash\n\n# Define the list of packages\npackages=(\n    \"libglib2.0-dev\" \n    \"libfdt-dev\" \n    \"libpixman-1-dev\" \n    \"zlib1g-dev\" \n    \"ninja-build\"\n    \"git\"\n    \"flex\"\n    \"bison\"\n    # Add more packages as needed\n)\n\n# Update package list\necho \"Updating package list...\"\nsudo apt update\n\n# Loop through the list and install each package\nfor package in \"${packages[@]}\"; do\n    echo \"Installing $package...\"\n    sudo apt install -y $package\ndone\n\necho \"Installing meson...\"\npip install meson\n\necho \"All packages have been installed!\"\n</code></pre></p>"},{"location":"tutorial/building_requirements/#configuring-the-build","title":"Configuring the build","text":"<p>To allow QEMU's system to be built along with your modifications, you would have to modify some of the files related to the build process. </p> <p>From this moment on, let's pretend that: - you're trying to implement a machine called mazinga, which mounts the SoC zeta - you defined the machine in <code>qemu/hw/arm/mazinga.c</code> and/or <code>qemu/include/hw/arm/mazinga.h</code> - you defined the SoC in <code>qemu/hw/arm/zeta_soc.c</code> and/or <code>qemu/include/hw/arm/zeta_soc.h</code> - your board also has a custom peripheral, let's say a custom UART, that you defined in <code>qemu/hw/char/zeta_uart.c</code> and/or <code>qemu/include/hw/char/zeta_uart.h</code>.</p> <p>The files to modify are the ones of the Meson build system and the ones of the Kconfig configuration system, relative to the ARM board you just created: 1. <code>qemu/hw/arm/Kconfig</code>     - add a line like:         <pre><code>system_ss.add(when: 'CONFIG_ZETA_UART', if_true: files('zeta_uart.c'))\n</code></pre>     - add the two <code>Config</code> clauses:         <pre><code>config MAZINGA\n    bool\n    default y\n    depends on TCG &amp;&amp; ARM\n    select ZETA_SOC\n</code></pre> <pre><code>config ZETA_SOC\n    bool\n    select &lt;your-cpu-architecture&gt; # eg. ARM_V7M\n</code></pre> 2. <code>qemu/hw/arm/meson.build</code>     - add a line like:         <pre><code>arm_ss.add(when: 'CONFIG_ZETA_SOC', if_true: files('zeta_soc.c'))\n</code></pre> 3. <code>qemu/configs/devices/arm-softmmu/default.mak</code>     - Even if not mandatory, you can use this file to filter out some ARM boards by default (so that even the Kconfig system could not enable them back) from being compiled when the command is issued. In fact, this file contains a list of every possible machine model and SoC as defined in the Kconfig we saw above, just with switched to uppercase.      - If you want to do this, add these lines.          <pre><code># CONFIG_MAZINGA=n\n# CONFIG_ZETA_SOC=n\n</code></pre>         De-commenting them will result in filtering your custom board out of the build process.</p>"},{"location":"tutorial/building_requirements/#launching-the-build-process","title":"Launching the build process","text":"<ol> <li>If it's the first time you build QEMU by yourself, you likely have no directory named <code>qemu/build</code>. If that's the case, run the <code>qemu/configure</code> script.</li> <li>If you want to specify only ARM targets, use <code>./configure --target-list=arm-softmmu</code></li> <li>You don't have to run this script every time you launch a new build, but only the first time ever, except if you want to change the compilation targets.</li> <li><code>cd</code> inside the <code>build</code> folder and Launch the build by issuing <code>make -j$(nproc)</code> or <code>ninja -C build</code>. Both commands use multi-threading to make the compilation faster.</li> <li>Once built, you can run your custom version from the <code>build</code> directory (eg. <code>./build/qemu-system-arm -M virt -cpu cortex-a15 -nographic</code>)</li> </ol>"},{"location":"tutorial/creating_board/","title":"Adding a custom board in QEMU","text":"<p>This section explains how to add a custom ARM-based board to QEMU. We\u2019ll guide you through the steps to define your board and make it ready for use in the QEMU emulator.</p> <p>\u26a0\ufe0f Before you begin...</p> <p>We highly suggest you to dive in QEMU fundamentals and its building requirements before beginning this journey!</p>"},{"location":"tutorial/creating_board/#machine-and-soc","title":"Machine and SoC","text":"<p>While it is technically possible to implement everything within a single C file, it is generally advisable to separate concerns: using header files for declarations and splitting implementation into multiple C files. In particular, we suggest to split the implementation of the new board into two coding steps (and therefore, into two files):  - writing a high-level definition of the new board (which we'll call machine from this point on, to align with QEMU's naming system)   - in this file we will address the implementation of something that QEMU will recognize as a Machine, therefore permitting us to run commands such as <code>qemu-system-arm -M &lt;our-new-machine&gt; -k kernel.elf</code>. Here we will mainly specify the valid CPU architecture that can be used with the <code>-cpu</code> argument and the clock frequency of the board. - writing a low-level definition of the SoC the Machine mounts.    - From our perspective, the SoC definition file will specify memory regions as well as every peripheral our custom board should be equipped with.</p> <p>Both of the files are to be inserted in the ARM boards' folder, which is <code>qemu/hw/arm</code>.</p> <p>In our opinion, this approach alignes with QEMU's internal logic and mimicks the structure of pre-implemented code.</p> <p>For example, the netduino2 machine, which is implemented in <code>qemu/hw/arm/netduino2.c</code>, is a high-level definition of a board mounting the stm32f205 SoC, which is defined at <code>qemu/hw/arm/stm32f205_soc.c</code> and <code>qemu/include/hw/arm/stm32f205_soc.h</code>).</p>"},{"location":"tutorial/creating_board/#creating-the-machine","title":"Creating the machine","text":"<ol> <li> <p><code>qemu/hw/arm/&lt;your-board&gt;.c</code></p> <ul> <li>This file contains only the high-level model of the board being implemented. Here we will define the system clock frequency, an <code>&lt;your-board&gt;_init</code> function and a <code>&lt;your-board&gt;_machine_init</code> function. </li> <li>The first one has prototype:     <pre><code> static void &lt;your-board&gt;_init(MachineState *machine)\n</code></pre>     and will instantiate the SoC entity and wire up a system clock source to the SoC. This is equivalent to the constructor of the instance/State of the machine in the QOM.     Moreover, this function will also load the kernel image given by the user by means of calling a function specific for your architecture (eg. <code>armv7m_load_kernel</code>).</li> <li> <p>The second one has prototype:     <pre><code>static void &lt;your-board&gt;_machine_init(MachineClass *mc)\n</code></pre>     this will bind the <code>_init</code> as constructor for the machine object, along with adding a description for your board and the valid CPU types it can mount. It's equivalent to the <code>_class_init</code> functions of the QOM.</p> </li> <li> <p>In the end, we will add a call to the <code>DEFINE_MACHINE</code> macro such as:     <pre><code>DEFINE_MACHINE(\"&lt;your-board&gt;\", &lt;your-board&gt;_machine_init)\n</code></pre>     which will register the machine Type into QEMU and link the <code>_machine_init</code> function as its Class constructor.</p> </li> </ul> </li> </ol> <p>\u2139\ufe0f Our code</p> <p>You can find our implementation of a custom machine in <code>qemu/hw/arm/nxp_s32k3x8evb.c</code></p>"},{"location":"tutorial/creating_board/#creating-the-soc","title":"Creating the SoC","text":"<ol> <li> <p><code>qemu/include/hw/arm/&lt;your-soc&gt;.h</code></p> <ul> <li>this file will declare global variables to be referred to in files that will actually construct our board, such as:</li> <li>base addresses and sizes of memory regions</li> <li>base addresses of any peripheral you would want to implement</li> <li>In this file you will also use a macro for the QEMU internal system to register the SoC as an internal Type.</li> <li> <p>in the include clauses of this file it's important to highlight the file containing the definition of the CPU architecture, which we will not implement from scratch.      <pre><code>#include \"hw/arm/armv7m.h\" // or your architecture of choice\n</code></pre></p> <p>\u2139\ufe0f CPU implementation from scratch</p> <p>If you need to implement a whole new CPU architecture beside the ones already supported in QEMU, refer to this.</p> </li> <li> <p>This file's major purpose is, in the end, to declare a <code>State</code> struct, containing all the attributes of our SoC: memory regions, the state of every attached peripheral and input lines for external sources of system/reference clocks. The <code>Type</code> and <code>Class</code> related to this will be instead implemented and registered in the <code>.c</code> file.</p> </li> </ul> </li> <li> <p><code>qemu/hw/arm/&lt;your-soc&gt;.c</code></p> </li> <li>this file will define the class and type of the SoC in depth. In particular, we will define three functions:       <pre><code>static void &lt;your-soc&gt;_initfn(Object *obj)\nstatic void &lt;your-soc&gt;_realize(DeviceState *dev_soc, Error **errp)\n</code></pre><ul> <li>the two are both initialization functions, but the first one is called early in the entity's lifecycle and it's a sort of \"shallow initialization\" of the device. Doesn't yet allocate or configure hardware resources (like memory regions or IRQs).</li> <li>the second one is the longest function. It does a sort of \"deep\" initialization of the SoC) and will \"do the dirty work\", in particular:<ul> <li>initialize clock sources that were not wired up by the machine code</li> <li>initialize memory regions</li> <li>realizes and connects the CPU to the SoC</li> <li>realizes and connects peripherals to the SoC</li> <li>connects IRQ lines of peripherals to the interrupt controller (in our ARM-based board, to the NVIC).</li> </ul> </li> </ul> </li> <li>moreover, in the same file we will:<ul> <li>declare the <code>_class_init</code> function, such as <code>static void &lt;your-soc&gt;_class_init(ObjectClass *class, void *data)</code>, which will bind only the <code>realize</code> method to the entity</li> <li>register the Type in the usual way, by means of calling the right macros. Make sure to bind the <code>instance_init</code> field of the <code>TypeInfo</code> structure to the <code>&lt;your-soc&gt;_initfn</code> function and the <code>class_init</code> field to the <code>&lt;your-soc&gt;_class_init</code> function.</li> </ul> </li> </ol> <p>\u2139\ufe0f Our code</p> <p>You can find our implementation of a SoC in <code>qemu/hw/arm/s32k3x8_soc.c</code> and <code>qemu/include/hw/arm/s32k3x8_soc.h</code>.</p>"},{"location":"tutorial/peripherals_example_GPIO/","title":"GPIO Mock Implementation","text":"<p>This document explains how the General Purpose Input/Output (GPIO) functionality is emulated in our QEMU-based environment for the S32K32X8 platform. Since QEMU does not provide native GPIO support for this microcontroller out-of-the-box, we created a mock implementation to simulate basic GPIO behavior for testing and demonstration purposes.</p>"},{"location":"tutorial/peripherals_example_GPIO/#overview","title":"Overview","text":"<ul> <li>File: <code>gpio.c</code></li> <li>Header: <code>gpio.h</code></li> <li>Purpose: Provide simple functions to emulate LED toggling and GPIO direction configuration in a QEMU environment.</li> </ul> <p>The code snippet creates mock registers and uses them to emulate reading and writing to GPIO pins.</p>"},{"location":"tutorial/peripherals_example_GPIO/#mock-registers","title":"Mock Registers","text":"<p>We define two volatile variables to simulate the registers usually provided by the MCU\u2019s hardware:</p> <pre><code>volatile uint32_t MOCK_GPIO_PDOR = 0; // Mock Port Data Output Register\nvolatile uint32_t MOCK_GPIO_PDDR = 0; // Mock Port Data Direction Register\n</code></pre>"},{"location":"tutorial/peripherals_example_GPIO/#aliases","title":"Aliases","text":"<pre><code>#define GPIO_PDOR MOCK_GPIO_PDOR\n#define GPIO_PDDR MOCK_GPIO_PDDR\n</code></pre> <p>These <code>#define</code> directives ensure that anywhere in the code we reference <code>GPIO_PDOR</code> or <code>GPIO_PDDR</code>, we are actually accessing our mock variables.</p>"},{"location":"tutorial/peripherals_example_GPIO/#code-explanation","title":"Code Explanation","text":""},{"location":"tutorial/peripherals_example_GPIO/#1-including-headers","title":"1. Including Headers","text":"<pre><code>#include \"gpio.h\"\n#include &lt;stdio.h&gt;\n</code></pre> <ul> <li><code>gpio.h</code> contains function prototypes and pin definitions.</li> <li><code>stdio.h</code> is used for basic I/O operations (optional).</li> </ul>"},{"location":"tutorial/peripherals_example_GPIO/#2-defining-the-led-pin","title":"2. Defining the LED Pin","text":"<pre><code>#define LED_PIN 3\n</code></pre> <p>We assume the LED is connected to pin 3. Adjust this value to match your desired pin.</p>"},{"location":"tutorial/peripherals_example_GPIO/#3-gpio-initialization","title":"3. GPIO Initialization","text":"<pre><code>void GPIO_Init(void) {\n    MOCK_GPIO_PDDR |= (1 &lt;&lt; LED_PIN); // Configure LED_PIN as output\n}\n</code></pre> <ul> <li>We set the direction of the <code>LED_PIN</code> as output by writing to <code>MOCK_GPIO_PDDR</code>.</li> <li><code>1 &lt;&lt; LED_PIN</code> shifts the bit corresponding to <code>LED_PIN</code> to the correct position.</li> </ul>"},{"location":"tutorial/peripherals_example_GPIO/#4-turning-the-led-on","title":"4. Turning the LED On","text":"<pre><code>void LED_On(void) {\n    MOCK_GPIO_PDOR |= (1 &lt;&lt; LED_PIN); // Set LED_PIN high\n}\n</code></pre> <ul> <li>We set the output bit of <code>LED_PIN</code> to 1 (high level) in <code>MOCK_GPIO_PDOR</code>.</li> </ul>"},{"location":"tutorial/peripherals_example_GPIO/#5-turning-the-led-off","title":"5. Turning the LED Off","text":"<pre><code>void LED_Off(void) {\n    MOCK_GPIO_PDOR &amp;= ~(1 &lt;&lt; LED_PIN); // Set LED_PIN low\n}\n</code></pre> <ul> <li>We clear the output bit of <code>LED_PIN</code> to 0 (low level) in <code>MOCK_GPIO_PDOR</code>.</li> </ul>"},{"location":"tutorial/peripherals_example_GPIO/#6-checking-led-state","title":"6. Checking LED State","text":"<pre><code>int LED_IsOn(void) {\n    return (MOCK_GPIO_PDOR &amp; (1 &lt;&lt; LED_PIN)) ? 1 : 0;\n}\n</code></pre> <ul> <li>We read the current state of the <code>LED_PIN</code> by checking if the corresponding bit is set in <code>MOCK_GPIO_PDOR</code>.</li> <li>Returns 1 if the LED is on, 0 if off.</li> </ul>"},{"location":"tutorial/peripherals_example_GPIO/#usage","title":"Usage","text":"<ol> <li> <p>Initialize the GPIO    Call <code>GPIO_Init()</code> once at the start of your program to configure the pin direction.</p> </li> <li> <p>Turn LED On/Off</p> </li> <li> <p><code>LED_On()</code> sets the LED pin high.</p> </li> <li> <p><code>LED_Off()</code> sets the LED pin low.</p> </li> <li> <p>Check LED State</p> </li> <li><code>LED_IsOn()</code> returns 1 if the LED pin is set, 0 otherwise.</li> </ol> <p>Example:</p> <pre><code>int main(void) {\n    GPIO_Init();         // Configure the LED pin\n    LED_On();            // Turn on the LED\n    printf(\"LED State: %d\\n\", LED_IsOn()); // Should print 1\n\n    LED_Off();           // Turn off the LED\n    printf(\"LED State: %d\\n\", LED_IsOn()); // Should print 0\n\n    return 0;\n}\n</code></pre>"},{"location":"tutorial/peripherals_example_GPIO/#why-a-mock-implementation","title":"Why a Mock Implementation?","text":"<p>In a real S32K3X8 microcontroller, registers like <code>GPIO_PDOR</code> and <code>GPIO_PDDR</code> are mapped to hardware addresses. Under QEMU, these registers do not exist unless explicitly emulated. This mock approach:</p> <ul> <li>Simulates the effect of writing to and reading from registers.</li> <li>Enables basic testing of GPIO logic in unit tests or continuous integration pipelines without the actual hardware.</li> </ul>"},{"location":"tutorial/peripherals_example_GPIO/#conclusion","title":"Conclusion","text":"<p>The mock GPIO implementation provides a straightforward way to emulate reading and writing to GPIO pins within QEMU for the S32K3X8 platform. This allows you to test code behavior (e.g., turning LEDs on and off) before deploying to physical hardware, reducing development time and potential hardware-related issues.</p>"},{"location":"tutorial/running_freeRTOS/","title":"Running FreeRTOS on your custom board","text":"<p>FreeRTOS is a lightweight and widely used real-time operating system that provides multitasking capabilities for embedded systems. It is particularly useful for resource-constrained devices, offering efficient task scheduling, synchronization, and memory management.</p> <p>When working with QEMU to emulate an embedded platform, several challenges arise in making FreeRTOS run correctly. However, in this document, we will not focus on the process of porting FreeRTOS to a new architecture. Instead, we will specifically address the scenario where a vendor already provides a FreeRTOS port for a real hardware board which is not supported by QEMU officially, and your goal is to replicate that board\u2019s behavior within QEMU.</p> <p>We will provide here a list of steps we discovered to be necessary for FreeRTOS to run on a machine we implemented from scratch. Our work was aimed to emulate the NXP S32K3X8_EVB evaluation board, so if you're dealing with a similar architecture, strictly follow this points:</p> <ol> <li>Download the FreeRTOS port from your vendor's site</li> <li>Insert the FreeRTOS source folder in your current work directory</li> <li>Write a suitable Makefile, in which you include in your source files every FreeRTOS functionality you may need, as you would in any FreeRTOS project. <ul> <li>In particular, if the board you're emulating includes a FPU, the FreeRTOS port you'll get from your vendor will surely exploit it. So, if using the <code>arm-none-eabi-gcc</code> toolchain to build, make sure you add specific flags in your <code>CFLAGS</code> to set the usage of the hardware (emulated by QEMU) floating-point unit (FPU) for floating-point operations. </li> <li>Since QEMU's ARM emulation might not perfectly replicate all the nuances of the hardware, especially the way FPU registers are handled, we suggest you to use the <code>softfp</code> ABI, which allows FreeRTOS to fall back to software emulation for floating-point operations when necessary, even if the processor\u2019s FPU is available. <pre><code>CFLAGS += -mfloat-abi=softfp\n</code></pre></li> </ul> </li> <li> <p>FreeRTOS expects several interrupt handlers to be implemented and linked inside of the Vector Table of your program, in your startup code. In particular, your Vector Table should look like this:</p> <pre><code>volatile uint32_t vector_table[] __attribute__((section(\".isr_vector\"))) = {\n    (uint32_t)STACK_START,        /* Stack Pointer */\n    (uint32_t)Reset_Handler,      /* Reset Handler */\n    (uint32_t)NMI_Handler,        /* NMI Handler */\n    (uint32_t)HardFault_Handler,  /* Hard Fault Handler */\n    (uint32_t)MemManage_Handler,  /* Reserved */\n    (uint32_t)BusFault_Handler,   /* Bus Fault Handler */\n    (uint32_t)UsageFault_Handler, /* Usage Fault Handler */\n    (uint32_t)0,                  /* Reserved */\n    (uint32_t)0,                  /* Reserved */\n    (uint32_t)0,                  /* Reserved */\n    (uint32_t)0,                  /* Reserved */\n    (uint32_t)vPortSVCHandler,    /* SVCall Handler */\n                                    // ^^ will call SVC_Handler eventually!\n    (uint32_t)DebugMon_Handler,   /* Debug Monitor Handler */\n    (uint32_t)0,                  /* Reserved */\n    (uint32_t)xPortPendSVHandler, /* PendSV Handler */\n                                    // ^^ will call PendSV_Handler eventually!\n    (uint32_t)xPortSysTickHandler,    /* SysTick Handler */\n};\n</code></pre> <ul> <li><code>vPortSVCHandler</code>, <code>xPortPendSVHandler</code> and <code>xPortSysTickHandler</code> are defined by FreeRTOS codebase itself, in the <code>port.c</code> file you will include in the Makefile.</li> <li>The other handlers are up to you to implement. If you have no requirements about those, however, you can leave them unspecified by declaring a function that only runs an infinite loop (except for the <code>Reset_Handler</code>, which has at least to call the real entrypoint of your user code: the <code>main</code> function).</li> </ul> </li> <li> <p>Make sure to declare also (even unspecified) functions <code>SVC_Handler</code> and <code>PendSV_Handler</code>, which will be called by their ported versions <code>vPortSVCHandler</code> and <code>xPortPendSVHandler</code> eventually, so your program will not compile if those are not declared.</p> </li> <li> <p>Write a suitable linker script for your project. In particular, make sure to add a <code>.heap</code> section in your RAM and set the <code>ENTRY</code> of your application to the the specific ISR <code>Reset_Handler</code>.</p> </li> <li> <p>In your <code>FreeRTOSConfig.h</code>, define <code>configCPU_CLOCK_HZ</code> properly to match your board's system clock frequency.</p> </li> </ol> <p>\u2139\ufe0f Our code</p> <p>You can find our implementation of working examples in <code>example_led/</code> and <code>example_morse/</code>.</p>"}]}